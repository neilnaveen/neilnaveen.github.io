<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Neil Naveen</title><link>https://neilnaveen.dev/posts/</link><description>Recent content in Posts on Neil Naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sat, 03 Sep 2022 11:28:06 -0500</lastBuildDate><atom:link href="https://neilnaveen.dev/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode-1899</title><link>https://neilnaveen.dev/posts/leetcode-1899/</link><pubDate>Sat, 03 Sep 2022 11:28:06 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-1899/</guid><description>In this solution, we are looking at all the triplets with values smaller than or equal to those in the target array and merging them into one triplet, temp.
This way, we will make the greatest triplet that is smaller than equal to the target triplet, which will be the closest we can make to target.
func mergeTriplets(triplets [][]int, target []int) bool { var temp [3]int // Loop through all triplets for _, i := range triplets { // If the triplet is smaller than or equal to the target if i[0] &amp;lt;= target[0] &amp;amp;&amp;amp; i[1] &amp;lt;= target[1] &amp;amp;&amp;amp; i[2] &amp;lt;= target[2] { // If the triplet is smaller than or equal to the target, merge it into temp temp = [3]int{max(i[0],temp[0]), max(i[1],temp[1]), max(i[2], temp[2])} } } // If temp is equal to target, return true return temp[0] == target[0] &amp;amp;&amp;amp; temp[1] == target[1] &amp;amp;&amp;amp; temp[2] == target[2] } // Helper function to get the max of two numbers func max (i, j int) int { if i &amp;gt; j { return i } else { return j } }</description><content type="html"><![CDATA[<p>In this solution, we are looking at all the triplets with values smaller than or equal to those in the target array and merging them into one triplet, <code>temp</code>.</p>
<p>This way, we will make the greatest triplet that is smaller than equal to the target triplet, which will be the closest we can make to target.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mergeTriplets</span>(<span style="color:#a6e22e">triplets</span> [][]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">target</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">temp</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Loop through all triplets
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">triplets</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If the triplet is smaller than or equal to the target
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">target</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">target</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i</span>[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">target</span>[<span style="color:#ae81ff">2</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// If the triplet is smaller than or equal to the target, merge it into temp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">temp</span> = [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>[<span style="color:#ae81ff">0</span>],<span style="color:#a6e22e">temp</span>[<span style="color:#ae81ff">0</span>]), <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>[<span style="color:#ae81ff">1</span>],<span style="color:#a6e22e">temp</span>[<span style="color:#ae81ff">1</span>]), <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>[<span style="color:#ae81ff">2</span>], <span style="color:#a6e22e">temp</span>[<span style="color:#ae81ff">2</span>])}
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If temp is equal to target, return true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">temp</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">target</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">temp</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">target</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">temp</span>[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">target</span>[<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Helper function to get the max of two numbers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">max</span> (<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &gt; <span style="color:#a6e22e">j</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span> 
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> { 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">j</span> 
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>Leetcode-62</title><link>https://neilnaveen.dev/posts/leetcode-62/</link><pubDate>Thu, 03 Mar 2022 11:28:06 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-62/</guid><description>https://leetcode.com/problems/unique-paths/
Explanation of solution Looking at this problem, we can recursively brute force all possible solutions by getting every single move we can make on the grid. First Solution: Brute Force Solution TLE
func uniquePaths(m int, n int) int { if m == 1 || n == 1{ return 1 } return uniquePaths(m - 1, n) + uniquePaths(m, n - 1) } Explanation of First Solution
Our base case is either when m == 1 or n == 1 If we have not hit our base case we add the recursive calls.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/unique-paths/">https://leetcode.com/problems/unique-paths/</a></p>
<h3 id="explanation-of-solution"><em><strong>Explanation of solution</strong></em></h3>
<p>Looking at this problem, we can recursively brute force all possible solutions by getting every single move we can make on the grid.
<img src="https://i.imgur.com/UeRxZ1M.jpg" alt=""></p>
<p><strong>First Solution: Brute Force Solution TLE</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">uniquePaths</span>(<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>{ <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">uniquePaths</span>(<span style="color:#a6e22e">m</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">n</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">uniquePaths</span>(<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Explanation of First Solution</strong></p>
<ul>
<li>Our base case is either when <code>m == 1</code> or <code>n == 1</code></li>
<li>If we have not hit our base case we add the recursive calls. We subtract from <code>m</code> making us move down and we subtract from <code>n</code> to move right.</li>
</ul>
<hr>
<p>Since the first solution, Time Limit Exceed, we can implement memoization to store results from a specific position in the matrix.</p>
<p><strong>Second Solution: Memoized Solution</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">uniquePaths</span>(<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pathFinder</span>(<span style="color:#a6e22e">m</span>,<span style="color:#a6e22e">n</span>, <span style="color:#66d9ef">map</span>[[<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>{})
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pathFinder</span>(<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">dp</span> <span style="color:#66d9ef">map</span>[[<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pos</span> = [<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">int</span>{ <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">n</span> }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">||</span> <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">pos</span>] &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">pos</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">pos</span>] = <span style="color:#a6e22e">pathFinder</span>(<span style="color:#a6e22e">m</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">dp</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">pathFinder</span>(<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">dp</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">pos</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p><strong>Explanation of Second Solution</strong></p>
<ul>
<li>The variable <code>pos</code> is the key for the <code>dp</code> map.</li>
<li>The if statment <code>(m == 1 || n == 1 ) || dp[pos] &gt; 0</code> is for when either we have hit the base case of <code>m</code> or <code>n</code> equaling <code>1</code> or <code>dp[pos] &gt; 0</code> meaning that we have already stored the result of <code>dp[pos]</code>.</li>
<li><code>dp[pos] = pathFinder(m - 1, n, dp) + pathFinder(m, n - 1, dp) - 1</code> is when we add the recursive calls of pathFinder, one of the calls being when we subtract from <code>m</code> essentially moving down, and one of the calls being when we subtract from <code>n</code> making us move to the right</li>
</ul>
<blockquote>
<p><em><strong>Upvote if This Solution helps</strong></em></p>
</blockquote>
]]></content></item><item><title>Leetcode-2154</title><link>https://neilnaveen.dev/posts/leetcode-2154/</link><pubDate>Tue, 01 Feb 2022 11:28:06 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-2154/</guid><description>2154
Intiution
We can iterate throught the whole array, if we find an element the same as original, we multiply original by 2 and reiterate through the the array with the new original . func findFinalValue(nums []int, original int) int { for i := 0 ; i &amp;lt; len(nums) ; i++{ if nums[i] == original { original *= 2 i = -1 } } return original }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/keep-multiplying-found-values-by-two/discuss/1734533/Iterative-One-Loop-O(1)-Space-solution">2154</a></p>
<p><strong>Intiution</strong></p>
<ul>
<li>We can iterate throught the whole array, if we find an element the same as original, we multiply original by 2 and reiterate through the  the array with the new original .
<img src="https://assets.leetcode.com/users/images/c1d55ad0-f192-411c-9dde-3c8134432c2a_1643643211.7857583.gif" alt="image"></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">findFinalValue</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">original</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span> ; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">nums</span>) ; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">original</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">original</span> <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">i</span> = <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">original</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>Leetcode-142</title><link>https://neilnaveen.dev/posts/leetcode-142/</link><pubDate>Wed, 19 Jan 2022 11:28:06 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-142/</guid><description>https://leetcode.com/problems/linked-list-cycle-ii/
Intuiton for both solutions If we keep on going through the linked list, there are two outcomes, Either we keep on iterating forever, or there is no cycle, and the loop ends We could store all are previously visited nodes to see if we have already visited them on a map If we find a node that is already in the map, we return that node If we break out of the linked list, we return nil because there is no cycle How the Two Pointer Solution Works</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">https://leetcode.com/problems/linked-list-cycle-ii/</a></p>
<h3 id="intuiton-for-both-solutions"><strong>Intuiton for both solutions</strong></h3>
<ul>
<li>If we keep on going through the linked list, there are two outcomes, Either we keep on iterating forever, or there is no cycle, and the loop ends</li>
<li>We could store all are previously visited nodes to see if we have already visited them on a map</li>
<li>If we find a node that is already in the map, we return that node</li>
<li>If we break out of the linked list, we return nil because there is no cycle</li>
</ul>
<p><strong>How the Two Pointer Solution Works</strong></p>
<p>In a nutshell, the two-pointer solution is just a sped-up version of the brute force solution. All we do is have a fast and slow pointer. We map the points we have visited with the slow pointer, and the fast pointer jumps ahead and checks if we have already seen that point.</p>
<p>Brute Force O(n) time</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">detectCycle</span>(<span style="color:#a6e22e">head</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>]<span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">curr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">curr</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">curr</span>] <span style="color:#f92672">==</span> <span style="color:#66d9ef">true</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">curr</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">curr</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">curr</span> = <span style="color:#a6e22e">curr</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Two Pointer Solution O(n/2) time</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">detectCycle</span>(<span style="color:#a6e22e">head</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">slow</span>,<span style="color:#a6e22e">fast</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">head</span>,<span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">visited</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>]<span style="color:#66d9ef">bool</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">fast</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>{
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">slow</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">slow</span> = <span style="color:#a6e22e">slow</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fast</span> = <span style="color:#a6e22e">fast</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">fast</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fast</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fast</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fast</span> = <span style="color:#a6e22e">fast</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">fast</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fast</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>Year-2021</title><link>https://neilnaveen.dev/posts/my-year-2021/</link><pubDate>Tue, 04 Jan 2022 11:07:06 -0500</pubDate><guid>https://neilnaveen.dev/posts/my-year-2021/</guid><description>I am 13 years old and have completed 395 problems in Leetcode. I have also finished most of the problems untill day 10 in Advent of Code 2021.
My Leetcode progress What is Leetcode Leetcode is a platform where you can improve your algorithmic skills by solving programing puzzles/problems https://leetcode.com/neilnaveen/
What I Have Done in Leetcode I have solved 390+ problems My Advent of Code progress for 2021 What is Advent of Code Advent of Code is a platform where every year starting from December 1 to December 25, there are algorithmic coding problems to solve.</description><content type="html"><![CDATA[<p>I am 13 years old and have completed 395 problems in Leetcode. I have also finished most of the problems untill day 10 in Advent of Code 2021.</p>
<hr>
<h2 id="my-leetcode-progress">My Leetcode progress</h2>
<h3 id="what-is-leetcode">What is Leetcode</h3>
<ul>
<li>Leetcode is a platform where you can improve your algorithmic skills by solving programing puzzles/problems</li>
</ul>
<p><a href="https://leetcode.com/neilnaveen/">https://leetcode.com/neilnaveen/</a></p>
<p><img src="https://i.imgur.com/qf2Zan1.png" alt=""></p>
<h3 id="what-i-have-done-in-leetcode">What I Have Done in Leetcode</h3>
<ul>
<li>I have solved 390+ problems</li>
</ul>
<h2 id="my-advent-of-code-progress-for-2021">My Advent of Code progress for 2021</h2>
<h3 id="what-is-advent-of-code">What is Advent of Code</h3>
<ul>
<li>Advent of Code is a platform where every year starting from December 1 to December 25, there are algorithmic coding problems to solve. Every day there are two problems to solve.</li>
</ul>
<p><a href="https://adventofcode.com">https://adventofcode.com </a></p>
<p><img src="https://i.imgur.com/LVA61PE.png" alt=""></p>
<h2 id="my-github-progress">My Github Progress</h2>
<p><a href="https://github.com/neilnaveen">https://github.com/neilnaveen</a>
<img src="https://i.imgur.com/JMAEymN.png" alt=""></p>
<h3 id="what-i-have-done-in-github">What I have done in Github</h3>
<ul>
<li>I have done 536 contributions in 2021</li>
</ul>
]]></content></item><item><title>Leetcode-495</title><link>https://neilnaveen.dev/posts/leetcode-495/</link><pubDate>Mon, 05 Jul 2021 11:28:06 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-495/</guid><description>495. Teemo Attacking
In this problem, we focus on that teemo&amp;rsquo;s attack duration is reset when teemo attacks again.
The code finds if teemo&amp;rsquo;s attacks overlap with the next attack. If it does, add the duration that the attack lasts before it is reset - 1. If not, add the duration to the result.
func findPoisonedDuration(timeSeries []int, duration int) int { res := 0 for i := 0 ; i &amp;lt; len(timeSeries)-1 ; i++{ if timeSeries[i] + duration-1 &amp;gt;= timeSeries[i+1]{ res += timeSeries[i+1] - timeSeries[i] }else{ res += duration } } res += duration return res }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/teemo-attacking/">495. Teemo Attacking</a></p>
<p>In this problem, we focus on that teemo&rsquo;s attack duration is reset when teemo attacks again.</p>
<p>The code finds if teemo&rsquo;s attacks overlap with the next attack. If it does, add the duration that the attack lasts before it is reset <code>- 1</code>.  If not, add the duration to the result.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">findPoisonedDuration</span>(<span style="color:#a6e22e">timeSeries</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">duration</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span> ; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">timeSeries</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">timeSeries</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">duration</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">timeSeries</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">timeSeries</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#a6e22e">timeSeries</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">duration</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">res</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">duration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>Leetcode-1413</title><link>https://neilnaveen.dev/posts/leetcode-1413/</link><pubDate>Mon, 05 Jul 2021 11:07:06 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-1413/</guid><description>1413. Minimum Value to Get Positive Step by Step Sum
The idea of the v2 solution is to find the smallest number in the step-by-step sums if your start num is 1. In the end, we add the smallest number we can to make all the steps positive
v2 solution O(n) time and O(1) space
func minStartValue(nums []int) int { sum := 1 min := 100000000 for _,j := range nums{ sum += j if sum &amp;lt;= min{ min = sum } } if min &amp;gt; 0 { return 1 } return (min*-1)+2 } v1 solution O(m*n) time and O(1) space</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/">1413. Minimum Value to Get Positive Step by Step Sum</a></p>
<p>The idea of the v2 solution is to find the smallest number in the step-by-step sums if your start num is <code>1</code>.  In the end, we add the smallest number we can to make all the steps positive</p>
<p>v2 solution O(n) time and O(1) space</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">minStartValue</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">min</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">100000000</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>,<span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">min</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">min</span> = <span style="color:#a6e22e">sum</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">min</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">min</span><span style="color:#f92672">*-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>v1 solution O(m*n) time and O(1) space</p>
<p>This is a brute force solution where we test from <code>0</code> to a <code>10000000000</code> for the start num in <code>m</code> time and see if the step by step addition is greater than <code>0</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">minStartValue</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span> ; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10000000000</span> ; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sum</span> = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">flag</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>,<span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span>{
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>{
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">flag</span> = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">flag</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>Leetcode-1323</title><link>https://neilnaveen.dev/posts/leetcode-1323/</link><pubDate>Sat, 03 Jul 2021 18:37:13 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-1323/</guid><description>1323. Maximum 69 Number
This problem is about taking a number, let&amp;rsquo;s say9669, and making it the largest number it could be by flipping one digit from a 6 to a 9.
The solution is made up of five parts.
We split the number into its digits.
We reverse the array of digits because it reverses the order when you split a number as we did.
Then we find the first 6 and change it to a 9.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/maximum-69-number/">1323. Maximum 69 Number</a></p>
<p>This problem is about taking a number, let&rsquo;s say<code>9669</code>, and making it the largest number it could be by flipping one digit from a <code>6</code> to a <code>9</code>.</p>
<p>The solution is made up of five parts.</p>
<ol>
<li>
<p>We split the number into its digits.</p>
</li>
<li>
<p>We reverse the array of digits because it reverses the order when you split a number as we did.</p>
</li>
<li>
<p>Then we find the first <code>6</code> and change it to a <code>9</code>.</p>
</li>
<li>
<p>Just before adding all the numbers together in a sum, we had to figure out how much should the digits be multiplied by to get into their correct form and not just the digits added up</p>
</li>
<li>
<p>Last of all, in code, the digits are summed up</p>
</li>
</ol>
<hr>
<p>In the first part, we add the last digit to the array and dividing the number by ten to take the last digit off. Now we have an array of the digits of the number reversed</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> num <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>{
</span></span><span style="display:flex;"><span>    arr <span style="color:#f92672">=</span> append(arr,num <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>    num<span style="color:#f92672">/=</span><span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p>This is the part for reversing the array. We have pointers on either side of the array. We then flip the digit on the left pointer digit with the right pointer digit and vice versa.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>l , r :<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> , len(arr)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> l <span style="color:#f92672">&lt;</span> r{ 
</span></span><span style="display:flex;"><span>    arr[l] , arr[r] <span style="color:#f92672">=</span> arr[r] , arr[l]
</span></span><span style="display:flex;"><span>    l<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>    r<span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p>This part finds the first digit that is a <code>6</code> and changes it to a <code>9</code>  by finding the first occurrence of a <code>6</code>, changing it to a 9, and breaking out of the loop, so it doesn&rsquo;t change more than one digit</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i2,i :<span style="color:#f92672">=</span> range arr{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">6</span>{
</span></span><span style="display:flex;"><span>        arr[i2] <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p>This part gets the number that we have to multiply to the last digit to get its place value. It does this by multiplying one by 10 for how long the number is <code>-1.</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>nummultiplyer :<span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i :<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> len(arr)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ; i<span style="color:#f92672">++</span>{
</span></span><span style="display:flex;"><span>    nummultiplyer <span style="color:#f92672">*=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p>This is the last part where we add all the digits to a sum. If we add the digits all by itself, the sum will not be like the given number with one digit flipped. We need to add the numbers times the <code>nummultiplyer</code> so it is at the correct place value and then divide the <code>nummultiplyer</code> by ten to the correct place value for the next number.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> _,i :<span style="color:#f92672">=</span> range arr{
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> i<span style="color:#f92672">*</span>nummultiplyer
</span></span><span style="display:flex;"><span>    nummultiplyer<span style="color:#f92672">/=</span><span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> sum
</span></span></code></pre></div><p>End Code</p>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maximum69Number</span>(<span style="color:#a6e22e">num</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// dividing up the number into a list of its digits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">num</span> &gt; <span style="color:#ae81ff">0</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">arr</span> = append(<span style="color:#a6e22e">arr</span>,<span style="color:#a6e22e">num</span><span style="color:#f92672">%</span><span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">num</span><span style="color:#f92672">/=</span><span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// reversing the list of digits , becasue when we made a list of all of the digits it was reversed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">l</span> , <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span> , len(<span style="color:#a6e22e">arr</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">r</span>{ 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">l</span>] , <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">r</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">r</span>] , <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">l</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">l</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">r</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// this is for finding the first digits that is a 6 and changing it to a nine
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i2</span>,<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">arr</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">6</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i2</span>] = <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// this is for finding how many zeros should the first number be multiplyed by
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">nummultiplyer</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span> ; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">arr</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">nummultiplyer</span> <span style="color:#f92672">*=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//and this is for remaking the list back into a array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>,<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">arr</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#a6e22e">nummultiplyer</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">nummultiplyer</span><span style="color:#f92672">/=</span><span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>Leetcode-1768</title><link>https://neilnaveen.dev/posts/leetcode-1768/</link><pubDate>Wed, 24 Feb 2021 16:51:02 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-1768/</guid><description>1768. Merge Strings Alternately func mergeAlternately(word1 string, word2 string) string { mergestringres := &amp;#34;&amp;#34; for i, i2 := range word1 { mergestringres += string(i2) if len(word2) &amp;gt; i { mergestringres += string(word2[i]) } } if len(word1) &amp;lt; len(word2) { mergestringres += word2[len(word1):] } return mergestringres }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/merge-strings-alternately/">1768. Merge Strings Alternately
</a></p>
<pre tabindex="0"><code>func mergeAlternately(word1 string, word2 string) string {
mergestringres := &#34;&#34;
for i, i2 := range word1 {
mergestringres += string(i2)

		if len(word2) &gt; i {
			mergestringres += string(word2[i])
			
		}
	}
	if len(word1) &lt; len(word2) {
		mergestringres += word2[len(word1):]
	}
	
	return mergestringres
}
</code></pre>]]></content></item></channel></rss>
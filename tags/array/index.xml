<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>array on Neil Naveen</title><link>https://neilnaveen.dev/tags/array/</link><description>Recent content in array on Neil Naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Mon, 05 Jul 2021 11:07:06 -0500</lastBuildDate><atom:link href="https://neilnaveen.dev/tags/array/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode-1413</title><link>https://neilnaveen.dev/posts/leetcode-1413/</link><pubDate>Mon, 05 Jul 2021 11:07:06 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-1413/</guid><description>1413. Minimum Value to Get Positive Step by Step Sum
The idea of the v2 solution is to find the smallest number in the step-by-step sums if your start num is 1. In the end, we add the smallest number we can to make all the steps positive
v2 solution O(n) time and O(1) space
func minStartValue(nums []int) int { sum := 1 min := 100000000 for _,j := range nums{ sum += j if sum &amp;lt;= min{ min = sum } } if min &amp;gt; 0 { return 1 } return (min*-1)+2 } v1 solution O(m*n) time and O(1) space</description></item></channel></rss>
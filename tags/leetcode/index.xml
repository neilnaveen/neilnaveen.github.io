<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>leetcode on Neil Naveen</title><link>https://neilnaveen.dev/tags/leetcode/</link><description>Recent content in leetcode on Neil Naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Mon, 05 Jul 2021 11:07:06 -0500</lastBuildDate><atom:link href="https://neilnaveen.dev/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode-1413</title><link>https://neilnaveen.dev/posts/leetcode-1413/</link><pubDate>Mon, 05 Jul 2021 11:07:06 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-1413/</guid><description>1413. Minimum Value to Get Positive Step by Step Sum
The idea of the v2 solution is to find the smallest number in the step-by-step sums if your start num is 1. In the end, we add the smallest number we can to make all the steps positive
v2 solution O(n) time and O(1) space
func minStartValue(nums []int) int { sum := 1 min := 100000000 for _,j := range nums{ sum += j if sum &amp;lt;= min{ min = sum } } if min &amp;gt; 0 { return 1 } return (min*-1)+2 } v1 solution O(m*n) time and O(1) space</description></item><item><title>Leetcode-1323</title><link>https://neilnaveen.dev/posts/leetcode-1323/</link><pubDate>Sat, 03 Jul 2021 18:37:13 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-1323/</guid><description>1323. Maximum 69 Number
This problem is about taking a number, let&amp;rsquo;s say9669, and making it the largest number it could be by flipping one digit from a 6 to a 9.
The solution is made up of five parts.
We split the number into its digits.
We reverse the array of digits because it reverses the order when you split a number as we did.</description></item><item><title>Leetcode-1768</title><link>https://neilnaveen.dev/posts/leetcode-1768/</link><pubDate>Wed, 24 Feb 2021 16:51:02 -0500</pubDate><guid>https://neilnaveen.dev/posts/leetcode-1768/</guid><description>1768. Merge Strings Alternately
func mergeAlternately(word1 string, word2 string) string { mergestringres := &amp;quot;&amp;quot; for i, i2 := range word1 { mergestringres += string(i2) if len(word2) &amp;gt; i { mergestringres += string(word2[i]) } } if len(word1) &amp;lt; len(word2) { mergestringres += word2[len(word1):] } return mergestringres }</description></item></channel></rss>